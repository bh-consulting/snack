\section{Création des certificats}
Lors de la mise en place d'une authentification par certificats sur le radius (par PEAP ,TLS ou TTLS), il nous faut avant tout générer un certificat 'racine' (ou d'authorité) à partir duquel tous les certificats seront signés (attestés). Puis, nous générerons des certificats: un pour le serveur radius et un par client si besoin (authentification TLS).
\subsection{Gérération du certificat racine}
Pour générer le certificat racine, un script Perl simple à apeller existe : CA.pl
La configuration préalable du script (affectation des variables) est donnée ci-dessous: 

\begin{alltt}
$SSLEAY_CONFIG="-config ./openssl.cnf";
$DAYS="-days 365";      # 1 year
$CADAYS="-days 1095";   # 3 years
$REQ="$openssl req $SSLEAY_CONFIG";
$CA="$openssl ca $SSLEAY_CONFIG";
$VERIFY="$openssl verify";
$X509="$openssl x509";
$PKCS12="$openssl pkcs12";

$CATOP="\textit{path/to/dir/}"

$CAKEY="./cakey.pem";
$CAREQ="./careq.pem";
$CACERT="./cacert.pem";

$DIRMODE = 0777;

$RET = 0;
\end{alltt}

Remarquons avant tout le \textit{path/to/dir} à spécifier. Il s'agit de la destination des fichiers générés.

On notera aussi la présence de l'option '-config ./openssl.cnf' qui impose la présence d'un fichier de configuration dans le dossier dans lequel l'appel du script sera fait. Cependant, on peut changer le chemin, ou même laisser la variable vide, ce qui aura pour effet une utilisation du fichier de configuration par default (/etc/ssl/openssl.cnf).

On crée donc le certificat racine et tous les répertoires nécessaire avec la commande:
\begin{verbatim}
$ ./CA.pl -newca 
\end{verbatim}

On presse alors la touche [Enter] pour signifier la création d'un nouveau certificat. Il ne reste alors qu'à remplir les champs demandés.
Penser à bien mémoriser la 'PEM pass phrase'. 
la commande 'ls' dans le dossier donne alors à peu près:  
\begin{verbatim}
-rw-rw-r-- 1 X X cacert.pem
-rwxr-xr-x 1 X X CA.pl
-rw-rw-r-- 1 X X careq.pem
drwxrwxr-x 2 X X certs
drwxrwxr-x 2 X X crl
-rw-rw-r-- 1 X X crlnumber
-rw-rw-r-- 1 X X index.txt
drwxrwxr-x 2 X X newcerts
-rw-r--r-- 1 X X openssl.cnf
drwxrwxr-x 2 X X private
\end{verbatim}
le dossier private contient aussi la clé du certificat.


\subsection{Génération et signature d'un certificat}
Pour créer un certificat client ou un certificat radius, on rapelle deux fois le même script perl, dans le répertoire dans lequel se situe ledit script: 

\begin{verbatim}
$ ./CA.pl -newreq
\end{verbatim}
De nouveau, nous somme invités à remplir les champs. Retenir la pass phrase utilisée. 
Si le certificat généré a pour vocation d'être utilisé sur le radius comme certificat serveur, le CN (Common Name) doit être le nom (hostname) de la machine.
Une fois la procédure terminée, un nouveau fichier est apparu: newreq.pem\\\\
On va donc signer ce nouveau certificat avec la commande: 
\begin{verbatim}
$ ./CA.pl -sign
\end{verbatim}
La pass phrase du certificat d'authorité nous sera alors demandée.

Une fois le certificat signé, on obtient 2 nouveaux fichiers : la clé (newkey.pem) et le certificat (newcert.pem). Ces fichiers peuvent être renomés et déplacés là où ils serviront (sur les machines des client si ce doit être des certificats clients). 


\section{Révocation des certificats}

Afin de simplifier la vérification de la validité des certificats proposés, le plus simple est de générer tous les certificats depuis la machine qui hébèrge le radius. Les dossiers générés par CA.pl anticipent déjà les mécanisme de révocation. Cependant, il n'est pas indispensable de tout faire depuis la même machine.\\\\
On peut noter la présence de fichiers 'serial' et 'index'. En effet, une trace des certificats générés est gardée. Il nous reste alors à générer une CRL (Certifiat Revocation List) pour annoncer quels certifcats sont bons, ou non. 
La génération est faite par la commande : 
\begin{verbatim}
$ openssl ca -config openssl.cnf -gencrl -out crl/crl.pem
\end{verbatim}

Il existe deux moyen de demander un 'check' de la validité d'un certificat. 
\subsection{Première methode de vérification de la validité d'un certificat (inutilisable pour le radius)}
Pour la première méthode, on donne le chemin du certificat racine uniquement. Cependant, il faut aupréalable avoir créer un lien portant le nom '\$hash.rX' et pointant vers la liste de révocation précédement générée (crl/crl.pem). Le X de .rX sera ici pris à 0. Il peut prendre d'autre valeur quand on gère plusieurs crl. De plus, lors de l'appel à 'openssl verify', il est impossible de spécifier un fichier de configuration (option '-config /path/to/conf/file'). Le fichier de configuration chargé est donc '/etc/ssl/openssl.cnf'. Le lien vers la liste de révocation dois donc être placé dans '/etc/ssl/certs/\$hash.ro' ou dans le dossier donné par la variable 'certs' du fichier /etc/ssl/openssl.cnf. Pour optenir la valeur de hash, on apelle la commande c\_hash dont le premier paramètre serait le nom (ou chemin) du certificat racine. Ceci reviens à la commande : 
\begin{verbatim}
$ openssl x509 -hash -noout -in /path/to/authority/certificate/cacert.pem
\end{verbatim}
Pour récapituler, la sequence à lancer est : 
\begin{verbatim}
$ c_hash cacert.pem
    79584399.0 => authority/cacert.pem
$ ln -s path/to/crl/crl.pem /etc/ssl/certs/79584399.r0
\end{verbatim}
Soit un certificat cert1 généré plus tôt.\\
Une fois fois la manipulation expliquée ci-dessus, on peut verifier la validité d'un certificat avec la commande: 
\begin{verbatim}
$ openssl verify -CAfile cacert.pem -crl_check cert1.pem
\end{verbatim}

\subsection{Deuxième méthode}
Pour cette deuxième technique, on précise non pas un fichier (certificat d'authorité) mais un chemin qui contient tant le certificat que la liste de révocation. Une fois encore, il va nous falloir en passer par l'utilisation de hash.
Une fois le hash récupéré, (cf méthode ci-dessus), on va créer deux liens dans le dossier qui nous arrange (classiquement, le dossier 'certs' généré par CA.pl). Le premier lien portera le nom \$hash.0 et pointera vers le certificat d'authorité. Le second, \$hash.r0 pointera vers la liste de certification. \\
Les commandes à lancer sont donc: 
\begin{verbatim}
$ c_hash cacert.pem
    79584399.0 => authority/cacert.pem
$ ln -s path/to/authority/certificate/cacert.pem path/to/certs/79584399.0
$ ln -s path/to/crl/crl.pem path/to/certs/79584399.r0
\end{verbatim}

La vérification de validité de certificats se fait cette fois avec la commande: 
\begin{verbatim}
$ openssl verify -CApath path/to/certs/ -crl_check cert1.pem
\end{verbatim}

\subsection{Révocation}
Lors de la vérification d'un certificat, la commande nous retourne normalement quelque chose de la forme : 
\begin{verbatim}
    cert1.pem: OK
\end{verbatim}
Nous pouvons alors révoquer un certificat avec la commande: 
\begin{verbatim}
$ openssl ca -config openssl.cnf -revoke cert1.pem
\end{verbatim}
Puis, il nous faudra générer la crl mise à jour: 
\begin{verbatim}
$ openssl ca -config openssl.cnf -gencrl -out crl/crl.pem
\end{verbatim}
Pas besoin de changer les liens donc, on peut imédiatement checker: 
\begin{verbatim}
$ openssl verify -CApath path/to/certs/ -crl_check cert1.pem
    error 23 at 0 depth lookup:certificate revoked
\end{verbatim}



\section{Mise en place du radius}

Coté radius, il nous faut disposer d'un certificat 'client' dont le Common Name correspond au nom de la machine qui hébèrge le serveur radius, ainsi que le certificat d'authorité (cacert.pem) qui nous permetra d'attester de la validité des certificats clients. 
De plus, il nous faut générer un fichier 'dh'. La procédure est expliquée dans le fichier de configuration: 
\begin{verbatim}
# openssl dhparam -check -text -5 512 -out dh
\end{verbatim}

La configuration est ensuite à faire dans le fichier eap.conf.
\begin{alltt}
tls \{
	confdir = \textit{path/to/certificate/}

        certdir = ${confdir}/certs
	cadir = ${confdir}/certs

	private_key_password = \textit{passphrase}
	private_key_file = ${cadir}/radius_key.pem
	certificate_file = ${certdir}/radius_cert.pem
	CA_file = ${cadir}/cacert.pem
	dh_file = ${cadir}/dh
	random_file = /dev/urandom
	fragment_size = 1024

	include_length = yes
	check_crl = yes
	CA_path = ${cadir}/certs
	.
	.
	.
    \}
\end{alltt}
Les chemins de destinations du certificat racine et du certificat serveur sont à préciser. 
La passphrase à spécifier est celle donnée lors de la création du certificat (Attention, pas du certificat d'authorité mais du certificat créé pour le radius).
Au début du fichier un protocole par 'default' est à préciser.
\begin{verbatim}
    default_eap_type = peap
\end{verbatim}
La spécification de ce protocole comme étant le défault ne rend pas les autre protocole inutilisables. Le serveur répondra de façon adaptée à chaque protocole qui aura été bien renseigné dans ce fichier eap.conf\\\\
Si une base sql est utilisée plustot que le fichier user pour manager les utilisateur, il faut changer le fichier /etc/freeradius/sites-available/inner-tunnel. Il suffit de commenter la ligne 'file' et décommenter 'sql'.\\
\begin{verbatim}
    #file
    sql
\end{verbatim}

\section{Mise en place coté client}
Coté client, il nous suffit de configurer un supplicant qui gère ceci. 
Voici 3 exemples de configurations fonctionnelles pour wpa\_supplicant sous linux. 
Pour tls:
\begin{alltt}
network=\{
    eap=TLS
    eapol_flags=0
    key_mgmt=IEEE8021X
    identity="\textit{userlogin}"
    ca_cert="path/to/authority/certificate/cacert.pem"
    client_cert="path/to/client/cert/cert.pem"
    private_key="path/to/client/key/key.pem"
    private_key_passwd="passphrase"
\}
\end{alltt}
La passphrase correspond à la passphrase spécifiée lors de la création du certificat client.\\
Pour ttls avec un encryptage MD5 dans le tunnel:
\begin{alltt}
network=\{
    eap=TTLS
    eapol_flags=0
    key_mgmt=IEEE8021X
    identity="\textit{userlogin}"
    password="\textit{userpassword}"
    ca_cert="path/to/authority/certificate/cacert.pem"
    phase2="auth=MD5"
\}
\end{alltt}
Pour peap:
\begin{alltt}
network=\{
    eap=PEAP
    eapol_flags=0
    key_mgmt=IEEE8021X
    identity="\textit{userlogin}"
    password="\textit{userpassword}"
    ca_cert="path/to/authority/certificate/cacert.pem"
    phase2="auth=MSCHAPV2"
\}
\end{alltt}

On peut alors appeler wpa\_supplicant avec la commande:
\begin{verbatim}
$ wpa_supplicant -ieth0 -c eapol_test.conf.tls -Dwired
\end{verbatim}
L'option -B permet de lancer wpa\_supplicant en background.







%\subsubsection{SubSub 1}

\newpage

\end{document}
