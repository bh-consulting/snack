\section{Certificats}
\subsection{Installation des certificats}
\subsubsection{Adaptation du fichier de configuration}

Ce paquet s'appuie sur \emph{openssl} pour la gestion des certificats.

Pour l'installer, en super-utilisateur~:

\begin{lstlisting}
# apt-get install openssl
\end{lstlisting}

On suppose un dossier pour les certificat de chemin~: §\emph{path\_to\_certs}§\\

Modifier le fichier de configuration \emph{/etc/ssl/openssl.cnf}~:

\begin{lstlisting}
   [ CA_default ]

    dir             = §\emph{path\_to\_certs}§              # Where everything is kept
    certs           = $dir/certs            # Where the issued certs are kept
    crl_dir         = $dir/crl              # Where the issued crl are kept
    database        = $dir/index.txt        # database index file.
    #unique_subject = no                    # Set to 'no' to allow creation of several ctificates with same subject.
    new_certs_dir   = $dir/newcerts         # default place for new certs.

    certificate     = $dir/§\textbf{private}§/cacert.pem       # The CA certificate
    serial          = $dir/serial           # The current serial number
    crlnumber       = $dir/crlnumber        # the current crl number must be commented out to leave a V1 CRL
    crl             = $dir/crl.pem          # The current CRL
    private_key     = $dir/private/cakey.pem# The private key
\end{lstlisting}

\subsubsection{Mise en place de l'environement}

Se placer dans le repertoire où seront stockés les certificats (\emph{path\_to\_certs}).

Créer les dossiers suivants~:

\begin{lstlisting}
$ mkdir "§\emph{path\_to\_certs}§/certs"
$ mkdir "§\emph{path\_to\_certs}§/crl"
$ mkdir "§\emph{path\_to\_certs}§/private"
$ mkdir "§\emph{path\_to\_certs}§/users"
$ mkdir "§\emph{path\_to\_certs}§/newcerts"
\end{lstlisting}

Ainsi que les fichiers~:

\begin{lstlisting}
$ touch §\emph{path\_to\_certs}§/index.txt
$ echo "01" > §\emph{path\_to\_certs}§/crlnumber
\end{lstlisting}

\subsubsection{Génération du certificat racine}

Créer le certificat racine sans passphrase avec openssl~:

\begin{lstlisting}
$ openssl genrsa -out §\emph{path\_to\_certs}§/private/cakey.pem 4096 
$ openssl req -new -key §\emph{path\_to\_certs}§/private/cakey.pem \
	-subj /countryName=FR/stateOrProvinceName=France/localityName=Nancy/organizationName=BHConsulting/commonName=§\emph{Nom\_de\_la\_société\_cliente}§/ \
	-out §\emph{path\_to\_certs}§/private/careq.pem

$ openssl ca -config /etc/ssl/openssl.cnf \
	-create_serial -out §\emph{path\_to\_certs}§/private/cacert.pem -days 3650 -batch \
	-keyfile §\emph{path\_to\_certs}§/private/cakey.pem -selfsign \
	-extensions v3_ca \
	-infiles §\emph{path\_to\_certs}§/private/careq.pem
\end{lstlisting}

Générer la liste des CRL (\emph{Certificate Revocation List}) dès à présent et \textbf{après chaque création/révocation} de certificat. Une seule génération peut être faite pour plusieurs modifications. La procédure est expliquée dans la section suivante.

\subsubsection{Génération et mise à jour de la CRL}

Première génération de la CRL~:

\begin{lstlisting}
$ openssl ca -config /etc/ssl/openssl.cnf -gencrl -out §\emph{path\_to\_certs}§/crl/crl.pem
\end{lstlisting}

\subsubsection{Architecture nécessaire pour la CRL}

Pour mettre en place l'architecture nécessaire à la lecture de CRL par Radius (prendre garde à utiliser des \textbf{chemins absolus} pour ces liens)~:

\begin{lstlisting}
$ export HASH=$(openssl x509 -noout -hash -in §\emph{path\_to\_certs}§/private/cacert.pem)
$ ln -s §\emph{path\_to\_certs}§/private/cacert.pem §\emph{path\_to\_certs}§/certs/$HASH.0
$ ln -s §\emph{path\_to\_certs}§/crl/crl.pem §\emph{path\_to\_certs}§/certs/$HASH.r0
\end{lstlisting}

\subsection{Utilisation des certificats}
\subsubsection{Génération et signature}

Créer un certificat pour l'utilisateur identifié par \emph{userName} (le champ \emph{commonName} doit correspondre au champ \emph{username} du Radius)~:

\begin{lstlisting}
$ openssl genrsa -out §\emph{path\_to\_certs}§/users/§\emph{userName\_key.pem}§ 4096

$ openssl req -config /etc/ssl/openssl.cnf -new -key §\emph{path\_to\_certs}§/users/§\emph{userName\_key.pem}§ \
        -subj /countryName=FR/stateOrProvinceName=France/localityName=Nancy/organizationName=BHConsulting/commonName=userName/ \
	-out §\emph{path\_to\_certs}§/users/\emph{userName\_req.pem} -days 3650

$ openssl ca -config /etc/ssl/openssl.cnf -policy policy_anything \
	-out §\emph{path\_to\_certs}§/users/\emph{userName\_cert.pem} -batch \
	-infiles §\emph{path\_to\_certs}§/users/\emph{userName\_req.pem}
\end{lstlisting}

Penser à mettre à jour la CRL.

\subsubsection{Révocation}

Pour révoquer un certificat (irréversible)~: 

\begin{lstlisting}
$ openssl ca -config /etc/ssl/openssl.cnf -revoke §\emph{path\_to\_certs}§/users/userName_cert.pem
\end{lstlisting}

Penser à mettre à jour la CRL.

Pour vérifier qu'un certificat a bien été révoqué~:

\begin{lstlisting}
$ openssl verify  -CApath §\emph{path\_to\_certs}§/certs/ \
    -crl_check §\emph{path\_to\_certs}§/users/userName_cert.pem
\end{lstlisting}

\subsection{Certificats et radius}
\subsubsection{Configuration du radius}

Pour mettre en place les certificats de Radius~: 

\begin{lstlisting}
$ dd if=/dev/urandom of=§\emph{path\_to\_certs}§/random count=2
$ openssl dhparam -check -text -5 1024 -out §\emph{path\_to\_certs}§/dh
\end{lstlisting}

Puis générer une clé et un certificat (dans \emph{path\_to\_certs/private} et non dans \emph{path\_to\_certs/users}).

Le \emph{commonName} du Radius \textbf{doit} être le hostname de la machine qui héberge le Radius.

Adapter ensuite le fichier \emph{/etc/freeradius/eap.conf}~:

\begin{lstlisting}
tls {
	confdir = §\emph{path\_to\_certs}§ 
	certdir = ${confdir}
	cadir = ${confdir}/private

	private_key_password =
	private_key_file = ${cadir}/radius_key.pem
	certificate_file = ${cadir}/radius_cert.pem
	CA_file = ${cadir}/cacert.pem
	dh_file = ${certdir}/dh
	random_file = /dev/urandom
	fragment_size = 1024

	include_length = yes
	check_crl = yes
	CA_path = ${certdir}/certs
	check_cert_cn = %{User-Name}

	§\emph{[...]}§
}
\end{lstlisting}

\subsubsection{Permissions}

Le Radius dois pouvoir lire plusieurs fichiers, comme la CRL, le certificat racine, son propre certificat, etc.

À titre d'exemple, voici les permissions utilisées (\emph{snack} est un groupe incluant les utilisateurs)~:

\begin{lstlisting}
snack
+-- [drwx--x--- root     snack   ]  cert
|   +-- [drwx------ root     snack   ]  certs
|   |   +-- [lrwxrwxrwx root     snack   ]  15661b30.0 -> /home/pi/snack/cert/private/cacert.pem
|   |   +-- [lrwxrwxrwx root     snack   ]  15661b30.r0 -> /home/pi/snack/cert/crl/crl.pem
|   +-- [drwxrwx--- root     snack   ]  crl
|   |   +-- [-rwxrwx--- freerad  snack   ]  crl.pem
|   +-- [-rw-r--r-- root     snack   ]  crlnumber
|   +-- [-rw-r--r-- root     snack   ]  crlnumber.old
|   +-- [-rwx------ freerad  snack   ]  dh
|   +-- [-rw-r--r-- root     snack   ]  index.txt
|   +-- [-rw-r--r-- root     snack   ]  index.txt.attr
|   +-- [-rw-r--r-- root     snack   ]  index.txt.attr.old
|   +-- [-rw-r--r-- root     snack   ]  index.txt.old
|   +-- [drwxrwx--- root     snack   ]  newcerts
|   |   +-- [-rw-r--r-- root     snack   ]  EDA9703A91A8EE1B.pem
|   |   +-- [-rw-r--r-- root     snack   ]  EDA9703A91A8EE1C.pem
|   +-- [drwx--x--- root     snack   ]  private
|   |   +-- [-rwx------ freerad  snack   ]  cacert.pem
|   |   +-- [-rwx------ root     snack   ]  cakey.pem
|   |   +-- [-rw-r--r-- root     snack   ]  careq.pem
|   |   +-- [-rwx------ freerad  snack   ]  radius_cert.pem
|   |   +-- [-rwx------ freerad  snack   ]  radius_key.pem
|   |   +-- [-rw-r--r-- root     snack   ]  radius_req.pem
|   +-- [-rwx------ freerad  snack   ]  random
|   +-- [-rw-r--r-- root     snack   ]  serial
|   +-- [-rw-r--r-- root     snack   ]  serial.old
|   +-- [drwxrwx--- root     snack   ]  users
+-- [drwx------ www-data snack   ]  scripts
    +-- [-rwx------ www-data snack   ]  createCertificate
    +-- [-rwx------ www-data snack   ]  revocationCheck
    +-- [-rwx------ www-data snack   ]  revokeClient
\end{lstlisting}

\subsection{Mise en place coté client}

Voici trois exemples de configuration fonctionnelle pour \emph{wpa\_supplicant} sous GNU/Linux. 

Pour TLS~:

\begin{lstlisting}
network={
    eap=TLS
    eapol_flags=0
    key_mgmt=IEEE8021X
    identity="§\emph{userlogin}§"
    ca_cert="path/to/authority/certificate/cacert.pem"
    client_cert="path/to/client/cert/cert.pem"
    private_key="path/to/client/key/key.pem"
}
\end{lstlisting}

Pour TTLS avec un encryptage MD5 dans le tunnel~:

\begin{lstlisting}
network={
    eap=TTLS
    eapol_flags=0
    key_mgmt=IEEE8021X
    identity="§\emph{userlogin}§"
    password="§\emph{userpassword}§"
    ca_cert="path/to/authority/certificate/cacert.pem"
    phase2="auth=MD5"
}
\end{lstlisting}

Pour PEAP~:

\begin{lstlisting}
network={
    eap=PEAP
    eapol_flags=0
    key_mgmt=IEEE8021X
    identity="§\textit{userlogin}§"
    password="§\textit{userpassword}§"
    ca_cert="path/to/authority/certificate/cacert.pem"
    phase2="auth=MSCHAPV2"
}
\end{lstlisting}

Pour utiliser les configurations avec \emph{wpa\_supplicant}~:

\begin{lstlisting}
$ wpa_supplicant -ieth0 -c eapol_test.conf.tls -Dwired
\end{lstlisting}

L'option \texttt{-B} permet de lancer \emph{wpa\_supplicant} en tâche de fond. Il faut toujours relancer Radius pour prendre en compte les modifications avant de tester.
